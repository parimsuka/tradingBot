'''
EXAMPLE AUTO TRADER

Do not edit this file directly. Instead, copy it somewhere else in your workspace.
These are simple bots that illustrate the Optibook API and some simple trading concepts. These bots will not make a profit.

This is an example bot that trades a single instrument C2_GREEN_ENERGY_ETF.
All it does is to randomly insert either a BID or an ASK every 5 seconds.
The price at which it inserts is equal to the opposite side of the order book.
Thus, if the best bid in the order book is currently 90, it will send a sell order for price 90.
If the best ask in the order book is 91, it will send a buy order for price 91.

The order type this bot uses is IOC (immediate or cancel). This means that if the order does not
immediately trade, it will not be visible to others in the order book. Instead, it will be cancelled automatically.
'''
import sys
import logging
import time
from typing import List
from optibook import common_types as t
from optibook import ORDER_TYPE_IOC, ORDER_TYPE_LIMIT, SIDE_ASK, SIDE_BID
from optibook.exchange_responses import InsertOrderResponse
from optibook.synchronous_client import Exchange
import numpy as np
import json

logging.getLogger('client').setLevel('INFO')
logger = logging.getLogger(__name__)
logger.handler = logging.StreamHandler(sys.stdout)
fh = logging.FileHandler("run.log")
fh.setLevel(logging.DEBUG)
fh.setFormatter(logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s"))
logger.addHandler(fh)


class Heidge:
    def __init__(self, basket, instruments):
        self.basket = basket
        self.instruments = instruments
        
HEIDGES = [Heidge('C2_GREEN_ENERGY_ETF', ['C2_SOLAR_CO', 'C2_WIND_LTD']),
           Heidge('C1_FOSSIL_FUEL_ETF', ['C1_GAS_INC', 'C1_OIL_CORP'])]
def print_report(e: Exchange):
    pnl = e.get_pnl()
    # positions = e.get_positions()
    for heidge in HEIDGES:
        basket_trades = e.poll_new_trades(heidge.basket)
        # instrument_trades = [e.poll_new_trades(instrument) for instrument in heidge.instruments]
        all_market_trades = e.poll_new_trade_ticks(heidge.basket)
        logger.info(f"{heidge.basket}, my trade: {len(basket_trades)}, others trade: {len(all_market_trades)}")
    logger.info("Pnl %s", pnl)

def print_order_response(order_response: InsertOrderResponse):
    if order_response.success:
        logger.info(f"Inserted order successfully, order_id='{order_response.order_id}'")
    else:
        logger.info(f"Unable to insert order with reason: '{order_response.success}'")

def clear_position(e: Exchange):
    positions = e.get_positions()
    for instrument_id, position in positions.items():
        if position == 0:
            continue
        # if there are positive position, sells it out; else buys it in
        price_book = e.get_last_price_book(instrument_id)
        if position > 0:
            side = SIDE_ASK
            # sells at the highest bid price
            if len(price_book.bids) == 0:
                logger.error(f"Position {position} cannot be cleared because there are no bids")
                return False
            price = price_book.bids[0].price
        else:
            side = SIDE_BID
            # buys at the lowest ask price
            if len(price_book.asks) == 0:
                logger.error(f"Position {position} cannot be cleared because there are no asks")
                return False
            price = price_book.asks[0].price
        # we don't want any hanging orders, so we use IOC
        volume = int(abs(position))
        response = e.insert_order(instrument_id, price=price, volume=volume, side=side, order_type='ioc')
        logger.info(f"Cleared position {position} for {instrument_id} with response {response}")
        return response


def verify_position(e, heidge, basket_response, instrument_responses):
    positions = e.get_positions()
    instruments = heidge.instruments + [heidge.basket]
    positions = {k: v for k, v in positions.items() if v != 0 and k in instruments}
    transanction_success = basket_response.success and all([response.success for response in instrument_responses])
    if len(positions) == 0 and transanction_success:
        logger.info("Transaction success without positions left")
        return True
    if len(positions) > 0 and transanction_success:
        logger.critical(f"[VERIFY_POSITION] Positions are not cleared: {positions}")
    if not transanction_success:
        logger.critical("[VERIFY_POSITION]Transaction failed")
    return False


def trade_cycle(e: Exchange):
    # this is the main bot logic which gets called every 5 seconds
    # fetch the current order book
    for heidge in HEIDGES:
        basket_name = heidge.basket
        instrument_ids = heidge.instruments
        basket_book = e.get_last_price_book(basket_name)
        # print("basket book", basket_book)
        instrument_books = [e.get_last_price_book(instrument_id) for instrument_id in instrument_ids]
        # print("instrument_books", instrument_books)
        # get the best bid and ask from the basket order book

        # If the asks and bids of either basket or instruments are empty, skip this iteration
        flag_empty = False
        if basket_book and basket_book.asks and basket_book.bids:
            basket_best_bid = basket_book.bids[0].price
            basket_best_ask = basket_book.asks[0].price
            basket_bid_volume = basket_book.bids[0].volume
            basket_ask_volume = basket_book.asks[0].volume
        else:
            logger.error(f"No bids or asks in basket book {basket_name}")
            flag_empty = True
        # get the best bid and ask from the instrument order books
        for instrument_book in instrument_books:
            if not(instrument_book and instrument_book.asks and instrument_book.bids):
                logger.error(f"No bids or asks in instrument {heidge.instruments}")
                flag_empty = True
        if flag_empty:
            continue
        # import pdb; pdb.set_trace()
        instrument_best_bids = [instrument_book.bids[0].price for instrument_book in instrument_books]
        instrument_bid_volumes = [instrument_book.bids[0].volume for instrument_book in instrument_books]
        instrument_best_asks = [instrument_book.asks[0].price for instrument_book in instrument_books]
        instrument_ask_volumes = [instrument_book.asks[0].volume for instrument_book in instrument_books]
        
        # Calculate the average instrument bid and ask
        avg_instrument_bid = sum(instrument_best_bids)/len(instrument_best_bids)
        avg_instrument_ask = sum(instrument_best_asks)/len(instrument_best_asks)

        
        sell_basket = basket_best_bid > avg_instrument_ask and not np.isclose(basket_best_bid, avg_instrument_ask)
        buy_basket = basket_best_ask < avg_instrument_bid and not np.isclose(basket_best_ask, avg_instrument_bid)
        logger.info(f"basket_best_bid: {basket_best_bid:.4f} > avg_instrument_ask: {avg_instrument_ask:.4f}? {sell_basket}")
        logger.info(f"basket_best_ask: {basket_best_ask:.4f} < avg_instrument_bid: {avg_instrument_bid:.4f}? {buy_basket}")
        # Scenario 1: Basket bid is higher than average instrument ask
        
        #**********#
        i = 1
        while sell_basket and i < len(basket_book.bids) and i < len(instrument_book.asks):
            if basket_book and basket_book.asks and basket_book.bids:
                basket_best_bid = basket_book.bids[i].price
                instrument_best_asks = [instrument_book.asks[i].price for instrument_book in instrument_books]
                avg_instrument_ask = sum(instrument_best_asks)/len(instrument_best_asks)
                
                logger.info(f"Scenario 1: Basket bid is higher than average instrument ask")
                # Calculate the possible volumes of shares to buy
                possible_volumes = min(basket_bid_volume//2, *instrument_ask_volumes)
                basket_sell_volumes = possible_volumes * 2
                instrument_buy_volumes = [possible_volumes] * 2  # this is for extensibility
                # sell basket
                basket_sell_response = e.insert_order(heidge.basket,
                                                      price=basket_best_bid,
                                                      volume=basket_sell_volumes,
                                                      side=SIDE_ASK,
                                                      order_type=ORDER_TYPE_IOC)
                # buy instruments
                instrument_buy_responses = []
                for instrument_id, instrument_buy_volume, instrument_best_ask\
                    in zip(heidge.instruments, instrument_buy_volumes, instrument_best_asks):
                    instrument_buy_response = e.insert_order(instrument_id,
                                                             price=instrument_best_ask,
                                                             volume=instrument_buy_volume,
                                                             side=SIDE_BID,
                                                             order_type=ORDER_TYPE_IOC)
                    instrument_buy_responses.append(instrument_buy_response)
                # print the responses
                logger.info(f"Basket sell response: {basket_sell_response}")
                logger.info(f"Instrument buy responses: {instrument_buy_responses}")
                verify_position(e, heidge, basket_sell_response, instrument_buy_responses)
            else:
                break
            sell_basket = basket_best_bid > avg_instrument_ask and not np.isclose(basket_best_bid, avg_instrument_ask)
            i+=1
        #**********#
        
        #**********#
        i = 1
        while buy_basket and i < len(basket_book.asks) and i < len(instrument_book.bids):
            if basket_book and basket_book.asks and basket_book.bids:
                basket_best_ask = basket_book.asks[i].price
                instrument_best_bids = [instrument_book.bids[i].price for instrument_book in instrument_books]
                avg_instrument_bid = sum(instrument_best_bids)/len(instrument_best_bids)
                
                logger.info(f"Scenario 2: Basket ask is lower than average instrument bid")
                # Calculate the possible volumes
                possible_volumes = min(basket_ask_volume//2, *instrument_bid_volumes)
                basket_buy_volume = possible_volumes * 2
                instrument_sell_volumes = [possible_volumes] * 2  # this is for extensibility
                # buy basket
                basket_buy_response = e.insert_order(heidge.basket,
                                                     price=basket_best_ask,
                                                     volume=basket_buy_volume,
                                                     side=SIDE_BID,
                                                     order_type=ORDER_TYPE_IOC)
                # sell instruments
                instrument_sell_responses = []
                for instrument_id, instrument_sell_volume, instrument_best_bid\
                    in zip(heidge.instruments, instrument_sell_volumes, instrument_best_bids):
                    instrument_sell_response = e.insert_order(instrument_id,
                                                              price=instrument_best_bid,
                                                              volume=instrument_sell_volume,
                                                              side=SIDE_ASK,
                                                              order_type=ORDER_TYPE_IOC)
                    instrument_sell_responses.append(instrument_sell_response)
                # print the responses
                logger.info(f"Basket buy response: {basket_buy_response}")
                logger.info(f"Instrument sell responses: {instrument_sell_responses}")
                verify_position(e, heidge, basket_buy_response, instrument_sell_responses)
            else:
                break
            buy_basket = basket_best_ask < avg_instrument_bid and not np.isclose(basket_best_ask, avg_instrument_bid)
            i+=1
        #**********#
        
        # if sell_basket:
        #     logger.info(f"Scenario 1: Basket bid is higher than average instrument ask")
        #     # Calculate the possible volumes of shares to buy
        #     possible_volumes = min(basket_bid_volume//2, *instrument_ask_volumes)
        #     basket_sell_volumes = possible_volumes * 2
        #     instrument_buy_volumes = [possible_volumes] * 2  # this is for extensibility
        #     # sell basket
        #     basket_sell_response = e.insert_order(heidge.basket,
        #                                           price=basket_best_bid,
        #                                           volume=basket_sell_volumes,
        #                                           side=SIDE_ASK,
        #                                           order_type=ORDER_TYPE_IOC)
        #     # buy instruments
        #     instrument_buy_responses = []
        #     for instrument_id, instrument_buy_volume, instrument_best_ask\
        #         in zip(heidge.instruments, instrument_buy_volumes, instrument_best_asks):
        #         instrument_buy_response = e.insert_order(instrument_id,
        #                                                  price=instrument_best_ask,
        #                                                  volume=instrument_buy_volume,
        #                                                  side=SIDE_BID,
        #                                                  order_type=ORDER_TYPE_IOC)
        #         instrument_buy_responses.append(instrument_buy_response)
        #     # print the responses
        #     logger.info(f"Basket sell response: {basket_sell_response}")
        #     logger.info(f"Instrument buy responses: {instrument_buy_responses}")
        #     verify_position(e, heidge, basket_sell_response, instrument_buy_responses)
        # # Scenario 2: Basket ask is lower than average instrument bid
        # if buy_basket:
        #     logger.info(f"Scenario 2: Basket ask is lower than average instrument bid")
        #     # Calculate the possible volumes
        #     possible_volumes = min(basket_ask_volume//2, *instrument_bid_volumes)
        #     basket_buy_volume = possible_volumes * 2
        #     instrument_sell_volumes = [possible_volumes] * 2  # this is for extensibility
        #     # buy basket
        #     basket_buy_response = e.insert_order(heidge.basket,
        #                                          price=basket_best_ask,
        #                                          volume=basket_buy_volume,
        #                                          side=SIDE_BID,
        #                                          order_type=ORDER_TYPE_IOC)
        #     # sell instruments
        #     instrument_sell_responses = []
        #     for instrument_id, instrument_sell_volume, instrument_best_bid\
        #         in zip(heidge.instruments, instrument_sell_volumes, instrument_best_bids):
        #         instrument_sell_response = e.insert_order(instrument_id,
        #                                                   price=instrument_best_bid,
        #                                                   volume=instrument_sell_volume,
        #                                                   side=SIDE_ASK,
        #                                                   order_type=ORDER_TYPE_IOC)
        #         instrument_sell_responses.append(instrument_sell_response)
        #     # print the responses
        #     logger.info(f"Basket buy response: {basket_buy_response}")
        #     logger.info(f"Instrument sell responses: {instrument_sell_responses}")
        #     verify_position(e, heidge, basket_buy_response, instrument_sell_responses)
    print_report(e)


def main():
    exchange = Exchange()
    exchange.connect()

    # you can also define host/user/pass yourself
    # when not defined, it is taken from ~/.optibook file if it exists
    # if that file does not exists, an error is thrown
    #exchange = Exchange(host='host-to-connect-to', info_port=7001, exec_port=8001, username='your-username', password='your-password')
    #exchange.connect()

    sleep_duration_sec = 0.2
    flag = True
    while True:
        # clear_position(exchange)
        trade_cycle(exchange)
        logger.debug(f'Iteration complete. Sleeping for {sleep_duration_sec} seconds')
        time.sleep(sleep_duration_sec)



if __name__ == '__main__':
    main()
